{"ast":null,"code":"import { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DoubleRange } from '../utils/double-range';\nimport { appendChildElement, redrawElement, pathAnimation, valueToCoefficient, getVisiblePoints } from '../../common/utils/helper';\nimport { getAnimationFunction, getPoint, getMinPointsDelta } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\n/**\n * Column Series Base\n */\n\nvar ColumnBase =\n/** @class */\nfunction () {\n  function ColumnBase() {}\n  /**\n   * To get the position of the column series.\n   * @return {DoubleRange}\n   * @private\n   */\n\n\n  ColumnBase.prototype.getSideBySideInfo = function (series) {\n    if (series.chart.enableSideBySidePlacement && !series.position) {\n      this.getSideBySidePositions(series);\n    }\n\n    var position = !series.chart.enableSideBySidePlacement ? 0 : series.position;\n    var rectCount = !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;\n    series.isRectSeries = true;\n    var visibleSeries = series.chart.visibleSeries;\n    var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing\n\n    var pointSpacing = series.columnWidth === null || isNaN(+series.columnWidth) ? series.type === 'Histogram' ? 1 : 0.7 : series.columnWidth; // Column width\n\n    var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);\n    var width = minimumPointDelta * pointSpacing;\n    var radius;\n    var location = position / rectCount - 0.5;\n    var doubleRange = new DoubleRange(location, location + 1 / rectCount);\n\n    if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {\n      doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);\n      radius = seriesSpacing * doubleRange.delta;\n      doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);\n    }\n\n    return doubleRange;\n  };\n  /**\n   * To get the rect values.\n   * @return {Rect}\n   * @private\n   */\n\n\n  ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {\n    var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n    var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n    return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));\n  };\n  /**\n   * To get the position of each series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.getSideBySidePositions = function (series) {\n    var chart = series.chart;\n\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var columnItem = _a[_i];\n\n      for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n        var item = _c[_b];\n        this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n      }\n    }\n  };\n\n  ColumnBase.prototype.findRectPosition = function (seriesCollection) {\n    var stackingGroup = [];\n    var vSeries = {\n      rectCount: 0,\n      position: null\n    };\n\n    for (var i = 0; i < seriesCollection.length; i++) {\n      var value = seriesCollection[i]; // tslint:disable-next-line:align\n\n      if (value.type.indexOf('Stacking') !== -1) {\n        if (value.stackingGroup) {\n          if (stackingGroup[value.stackingGroup] === undefined) {\n            value.position = vSeries.rectCount;\n            stackingGroup[value.stackingGroup] = vSeries.rectCount++;\n          } else {\n            value.position = stackingGroup[value.stackingGroup];\n          }\n        } else {\n          if (vSeries.position === null) {\n            value.position = vSeries.rectCount;\n            vSeries.position = vSeries.rectCount++;\n          } else {\n            value.position = vSeries.position;\n          }\n        }\n      } else {\n        value.position = vSeries.rectCount++;\n      }\n    } // tslint:disable-next-line:align\n\n\n    for (var i = 0; i < seriesCollection.length; i++) {\n      var value = seriesCollection[i];\n      value.rectCount = vSeries.rectCount;\n    }\n  };\n  /**\n   * Updates the symbollocation for points\n   * @return void\n   * @private\n   */\n\n\n  ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {\n    if (!series.chart.requireInvertedAxis) {\n      this.updateXRegion(point, rect, series);\n    } else {\n      this.updateYRegion(point, rect, series);\n    }\n\n    if (series.type === 'Histogram') {\n      point.minimum = +point.x - series.histogramValues.binWidth / 2;\n      point.maximum = +point.x + series.histogramValues.binWidth / 2;\n    }\n  };\n  /**\n   * Update the region for the point.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.updateXRegion = function (point, rect, series) {\n    point.symbolLocations.push({\n      x: rect.x + rect.width / 2,\n      y: series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 || point.yValue >= 0 === !series.yAxis.isInversed ? rect.y : rect.y + rect.height\n    });\n    this.getRegion(point, rect, series);\n\n    if (series.type === 'RangeColumn') {\n      point.symbolLocations.push({\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height\n      });\n    }\n  };\n  /**\n   * Update the region for the point in bar series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.updateYRegion = function (point, rect, series) {\n    point.symbolLocations.push({\n      x: series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 || point.yValue >= 0 === !series.yAxis.isInversed ? rect.x + rect.width : rect.x,\n      y: rect.y + rect.height / 2\n    });\n    this.getRegion(point, rect, series);\n\n    if (series.type === 'RangeColumn') {\n      point.symbolLocations.push({\n        x: rect.x,\n        y: rect.y + rect.height / 2\n      });\n    }\n  };\n  /**\n   * To render the marker for the series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.renderMarker = function (series) {\n    if (series.marker && series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * To get the marker region when Y value is 0\n   * @param point\n   * @param series\n   */\n\n\n  ColumnBase.prototype.getRegion = function (point, rect, series) {\n    if (point.y === 0) {\n      var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;\n      var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;\n      point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n    } else {\n      point.regions.push(rect);\n    }\n  };\n  /**\n   * To trigger the point rendering event.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: series.setPointColor(point, fill),\n      border: series.setBorderColor(point, border)\n    };\n    series.chart.trigger(pointRender, argsData);\n    point.color = argsData.fill;\n    return argsData;\n  };\n  /**\n   * To draw the rectangle for points.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {\n    var chart = series.chart;\n    var check = chart.requireInvertedAxis ? rect.height : rect.width;\n\n    if (check <= 0) {\n      return null;\n    }\n\n    var direction;\n\n    if (point.y === 0) {\n      // For 0 values corner radius will not calculate\n      direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);\n    } else {\n      direction = this.calculateRoundedRectPath(rect, series.cornerRadius.topLeft, series.cornerRadius.topRight, series.cornerRadius.bottomLeft, series.cornerRadius.bottomRight);\n    }\n\n    var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name + '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n    var previousElement = redrawElement(chart.redraw, name);\n    var previousDirection = previousElement ? previousElement.getAttribute('d') : '';\n    var options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n    var element = chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n\n    switch (series.seriesType) {\n      case 'XY':\n        element.setAttribute('aria-label', point.x.toString() + ':' + point.yValue.toString());\n        break;\n\n      case 'HighLow':\n        element.setAttribute('aria-label', point.x.toString() + ':' + point.high.toString() + ':' + point.low.toString());\n        break;\n    }\n\n    appendChildElement(series.chart.enableCanvas, series.seriesElement, element, chart.redraw);\n\n    if (!series.chart.enableCanvas) {\n      pathAnimation(element, direction, chart.redraw, previousDirection, chart.duration);\n    }\n  };\n  /**\n   * To animate the series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.animate = function (series) {\n    var rectElements = series.seriesElement.childNodes;\n    var count = series.category === 'Indicator' ? 0 : 1;\n    var visiblePoints = getVisiblePoints(series);\n\n    for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n      var point = visiblePoints_1[_i];\n\n      if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {\n        continue;\n      }\n\n      this.animateRect(rectElements[count], series, point);\n      count++;\n    }\n  };\n  /**\n   * To animate the series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.animateRect = function (element, series, point) {\n    var option = series.animation;\n    var duration = series.chart.animated ? series.chart.duration : option.duration;\n    var effect = getAnimationFunction('Linear');\n    var isPlot = point.yValue < 0;\n    var x;\n    var y;\n    var elementHeight = +point.regions[0].height;\n    var elementWidth = +point.regions[0].width;\n    var centerX;\n    var centerY;\n\n    if (!series.chart.requireInvertedAxis) {\n      x = +point.regions[0].x;\n\n      if (series.type.indexOf('Stacking') > -1) {\n        y = (1 - valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.height;\n        centerX = x;\n        centerY = y;\n      } else {\n        y = +point.regions[0].y;\n        centerY = series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1 ? y + elementHeight / 2 : isPlot !== series.yAxis.isInversed ? y : y + elementHeight;\n        centerX = isPlot ? x : x + elementWidth;\n      }\n    } else {\n      y = +point.regions[0].y;\n\n      if (series.type.indexOf('Stacking') > -1) {\n        x = valueToCoefficient(0, series.yAxis) * series.yAxis.rect.width;\n        centerX = x;\n        centerY = y;\n      } else {\n        x = +point.regions[0].x;\n        centerY = isPlot ? y : y + elementHeight;\n        centerX = series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1 ? x + elementWidth / 2 : isPlot !== series.yAxis.isInversed ? x + elementWidth : x;\n      }\n    }\n\n    var value;\n\n    if (!isNullOrUndefined(element)) {\n      element.style.visibility = 'hidden';\n      new Animation({}).animate(element, {\n        duration: duration,\n        delay: option.delay,\n        progress: function (args) {\n          if (args.timeStamp >= args.delay) {\n            element.style.visibility = 'visible';\n\n            if (!series.chart.requireInvertedAxis) {\n              elementHeight = elementHeight ? elementHeight : 1;\n              value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n              element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(1,' + value / elementHeight + ') translate(' + -centerX + ' ' + -centerY + ')');\n            } else {\n              elementWidth = elementWidth ? elementWidth : 1;\n              value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n              element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + value / elementWidth + ', 1) translate(' + -centerX + ' ' + -centerY + ')');\n            }\n          }\n        },\n        end: function (model) {\n          element.setAttribute('transform', 'translate(0,0)');\n          var seriesElement = series.seriesElement;\n\n          if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 || series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2]) {\n            series.chart.trigger('animationComplete', {\n              series: series.chart.isBlazor ? {} : series\n            });\n\n            if (series.type === 'Waterfall') {\n              var rectElements = seriesElement.childNodes;\n\n              for (var i = 0; i < rectElements.length; i++) {\n                if (rectElements[i].id.indexOf('Connector') !== -1) {\n                  rectElements[i].style.visibility = 'visible';\n                  rectElements[i].setAttribute('transform', 'translate(0,0)');\n                }\n              }\n            }\n          }\n        }\n      });\n    }\n  };\n  /**\n   * To get rounded rect path direction\n   */\n\n\n  ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight) {\n    return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) + ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y + ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' + (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight) + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' + (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' + (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' + (topLeft + rect.y) + ' ' + 'Z';\n  };\n\n  return ColumnBase;\n}();\n\nexport { ColumnBase };","map":{"version":3,"sources":["C:/Users/Power GSM/Desktop/React-Fito-v1.0-9-April-2021V/React-Fito-v1.0-9-April-2021V/react-fito/node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js"],"names":["Animation","isNullOrUndefined","DoubleRange","appendChildElement","redrawElement","pathAnimation","valueToCoefficient","getVisiblePoints","getAnimationFunction","getPoint","getMinPointsDelta","PathOption","Rect","pointRender","ColumnBase","prototype","getSideBySideInfo","series","chart","enableSideBySidePlacement","position","getSideBySidePositions","rectCount","isRectSeries","visibleSeries","seriesSpacing","columnSpacing","pointSpacing","columnWidth","isNaN","type","minimumPointDelta","xAxis","width","radius","location","doubleRange","start","end","delta","getRectangle","x1","y1","x2","y2","point1","yAxis","requireInvertedAxis","point2","Math","min","x","y","abs","_i","_a","columns","length","columnItem","_b","_c","rows","item","findRectPosition","findSeriesCollection","seriesCollection","stackingGroup","vSeries","i","value","indexOf","undefined","updateSymbolLocation","point","rect","updateXRegion","updateYRegion","minimum","histogramValues","binWidth","maximum","symbolLocations","push","seriesType","yValue","isInversed","height","getRegion","renderMarker","marker","visible","markerRender","render","markerWidth","markerHeight","regions","triggerEvent","fill","border","argsData","cancel","name","setPointColor","setBorderColor","trigger","color","drawRectangle","check","direction","calculateRoundedRectPath","cornerRadius","topLeft","topRight","bottomLeft","bottomRight","category","element","id","index","previousElement","redraw","previousDirection","getAttribute","options","opacity","dashArray","renderer","drawPath","Int32Array","clipRect","setAttribute","toString","high","low","enableCanvas","seriesElement","duration","animate","rectElements","childNodes","count","visiblePoints","visiblePoints_1","animateRect","option","animation","animated","effect","isPlot","elementHeight","elementWidth","centerX","centerY","style","visibility","delay","progress","args","timeStamp","model","lastElementChild","points","children","childElementCount","isBlazor"],"mappings":"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","sourcesContent":["import { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DoubleRange } from '../utils/double-range';\nimport { appendChildElement, redrawElement, pathAnimation, valueToCoefficient, getVisiblePoints } from '../../common/utils/helper';\nimport { getAnimationFunction, getPoint, getMinPointsDelta } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\n/**\n * Column Series Base\n */\nvar ColumnBase = /** @class */ (function () {\n    function ColumnBase() {\n    }\n    /**\n     * To get the position of the column series.\n     * @return {DoubleRange}\n     * @private\n     */\n    ColumnBase.prototype.getSideBySideInfo = function (series) {\n        if (series.chart.enableSideBySidePlacement && !series.position) {\n            this.getSideBySidePositions(series);\n        }\n        var position = !series.chart.enableSideBySidePlacement ? 0 : series.position;\n        var rectCount = !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;\n        series.isRectSeries = true;\n        var visibleSeries = series.chart.visibleSeries;\n        var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing\n        var pointSpacing = (series.columnWidth === null || isNaN(+series.columnWidth)) ? ((series.type === 'Histogram') ? 1 : 0.7) :\n            series.columnWidth; // Column width\n        var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);\n        var width = minimumPointDelta * pointSpacing;\n        var radius;\n        var location = (position) / rectCount - 0.5;\n        var doubleRange = new DoubleRange(location, location + (1 / rectCount));\n        if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {\n            doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);\n            radius = seriesSpacing * doubleRange.delta;\n            doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);\n        }\n        return doubleRange;\n    };\n    /**\n     * To get the rect values.\n     * @return {Rect}\n     * @private\n     */\n    ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {\n        var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n        var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n        return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));\n    };\n    /**\n     * To get the position of each series.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.getSideBySidePositions = function (series) {\n        var chart = series.chart;\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var columnItem = _a[_i];\n            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n                var item = _c[_b];\n                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n            }\n        }\n    };\n    ColumnBase.prototype.findRectPosition = function (seriesCollection) {\n        var stackingGroup = [];\n        var vSeries = { rectCount: 0, position: null };\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            // tslint:disable-next-line:align\n            if (value.type.indexOf('Stacking') !== -1) {\n                if (value.stackingGroup) {\n                    if (stackingGroup[value.stackingGroup] === undefined) {\n                        value.position = vSeries.rectCount;\n                        stackingGroup[value.stackingGroup] = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = stackingGroup[value.stackingGroup];\n                    }\n                }\n                else {\n                    if (vSeries.position === null) {\n                        value.position = vSeries.rectCount;\n                        vSeries.position = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = vSeries.position;\n                    }\n                }\n            }\n            else {\n                value.position = vSeries.rectCount++;\n            }\n        }\n        // tslint:disable-next-line:align\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            value.rectCount = vSeries.rectCount;\n        }\n    };\n    /**\n     * Updates the symbollocation for points\n     * @return void\n     * @private\n     */\n    ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {\n        if (!series.chart.requireInvertedAxis) {\n            this.updateXRegion(point, rect, series);\n        }\n        else {\n            this.updateYRegion(point, rect, series);\n        }\n        if (series.type === 'Histogram') {\n            point.minimum = +point.x - series.histogramValues.binWidth / 2;\n            point.maximum = +point.x + series.histogramValues.binWidth / 2;\n        }\n    };\n    /**\n     * Update the region for the point.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.updateXRegion = function (point, rect, series) {\n        point.symbolLocations.push({\n            x: rect.x + (rect.width) / 2,\n            y: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||\n                (point.yValue >= 0 === !series.yAxis.isInversed)) ? rect.y : (rect.y + rect.height)\n        });\n        this.getRegion(point, rect, series);\n        if (series.type === 'RangeColumn') {\n            point.symbolLocations.push({\n                x: rect.x + (rect.width) / 2,\n                y: rect.y + rect.height\n            });\n        }\n    };\n    /**\n     * Update the region for the point in bar series.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.updateYRegion = function (point, rect, series) {\n        point.symbolLocations.push({\n            x: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||\n                (point.yValue >= 0 === !series.yAxis.isInversed)) ? rect.x + rect.width : rect.x,\n            y: rect.y + rect.height / 2\n        });\n        this.getRegion(point, rect, series);\n        if (series.type === 'RangeColumn') {\n            point.symbolLocations.push({\n                x: rect.x,\n                y: rect.y + rect.height / 2\n            });\n        }\n    };\n    /**\n     * To render the marker for the series.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.renderMarker = function (series) {\n        if (series.marker && series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * To get the marker region when Y value is 0\n     * @param point\n     * @param series\n     */\n    ColumnBase.prototype.getRegion = function (point, rect, series) {\n        if (point.y === 0) {\n            var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;\n            var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;\n            point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n        }\n        else {\n            point.regions.push(rect);\n        }\n    };\n    /**\n     * To trigger the point rendering event.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {\n        var argsData = {\n            cancel: false, name: pointRender, series: series, point: point,\n            fill: series.setPointColor(point, fill),\n            border: series.setBorderColor(point, border)\n        };\n        series.chart.trigger(pointRender, argsData);\n        point.color = argsData.fill;\n        return argsData;\n    };\n    /**\n     * To draw the rectangle for points.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {\n        var chart = series.chart;\n        var check = chart.requireInvertedAxis ? rect.height : rect.width;\n        if (check <= 0) {\n            return null;\n        }\n        var direction;\n        if (point.y === 0) {\n            // For 0 values corner radius will not calculate\n            direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);\n        }\n        else {\n            direction = this.calculateRoundedRectPath(rect, series.cornerRadius.topLeft, series.cornerRadius.topRight, series.cornerRadius.bottomLeft, series.cornerRadius.bottomRight);\n        }\n        var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name +\n            '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n        var previousElement = redrawElement(chart.redraw, name);\n        var previousDirection = previousElement ? previousElement.getAttribute('d') : '';\n        var options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n        var element = chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        switch (series.seriesType) {\n            case 'XY':\n                element.setAttribute('aria-label', point.x.toString() + ':' + point.yValue.toString());\n                break;\n            case 'HighLow':\n                element.setAttribute('aria-label', point.x.toString() + ':' + point.high.toString() + ':' + point.low.toString());\n                break;\n        }\n        appendChildElement(series.chart.enableCanvas, series.seriesElement, element, chart.redraw);\n        if (!series.chart.enableCanvas) {\n            pathAnimation(element, direction, chart.redraw, previousDirection, chart.duration);\n        }\n    };\n    /**\n     * To animate the series.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.animate = function (series) {\n        var rectElements = series.seriesElement.childNodes;\n        var count = series.category === 'Indicator' ? 0 : 1;\n        var visiblePoints = getVisiblePoints(series);\n        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n            var point = visiblePoints_1[_i];\n            if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {\n                continue;\n            }\n            this.animateRect(rectElements[count], series, point);\n            count++;\n        }\n    };\n    /**\n     * To animate the series.\n     * @return {void}\n     * @private\n     */\n    ColumnBase.prototype.animateRect = function (element, series, point) {\n        var option = series.animation;\n        var duration = series.chart.animated ? series.chart.duration : option.duration;\n        var effect = getAnimationFunction('Linear');\n        var isPlot = point.yValue < 0;\n        var x;\n        var y;\n        var elementHeight = +point.regions[0].height;\n        var elementWidth = +point.regions[0].width;\n        var centerX;\n        var centerY;\n        if (!series.chart.requireInvertedAxis) {\n            x = +point.regions[0].x;\n            if (series.type.indexOf('Stacking') > -1) {\n                y = (1 - valueToCoefficient(0, series.yAxis)) * (series.yAxis.rect.height);\n                centerX = x;\n                centerY = y;\n            }\n            else {\n                y = +point.regions[0].y;\n                centerY = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? y + elementHeight / 2 :\n                    (isPlot !== series.yAxis.isInversed) ? y : y + elementHeight;\n                centerX = isPlot ? x : x + elementWidth;\n            }\n        }\n        else {\n            y = +point.regions[0].y;\n            if (series.type.indexOf('Stacking') > -1) {\n                x = (valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.width;\n                centerX = x;\n                centerY = y;\n            }\n            else {\n                x = +point.regions[0].x;\n                centerY = isPlot ? y : y + elementHeight;\n                centerX = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? x + elementWidth / 2 :\n                    (isPlot !== series.yAxis.isInversed) ? x + elementWidth : x;\n            }\n        }\n        var value;\n        if (!isNullOrUndefined(element)) {\n            element.style.visibility = 'hidden';\n            new Animation({}).animate(element, {\n                duration: duration,\n                delay: option.delay,\n                progress: function (args) {\n                    if (args.timeStamp >= args.delay) {\n                        element.style.visibility = 'visible';\n                        if (!series.chart.requireInvertedAxis) {\n                            elementHeight = elementHeight ? elementHeight : 1;\n                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +\n                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');\n                        }\n                        else {\n                            elementWidth = elementWidth ? elementWidth : 1;\n                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +\n                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');\n                        }\n                    }\n                },\n                end: function (model) {\n                    element.setAttribute('transform', 'translate(0,0)');\n                    var seriesElement = series.seriesElement;\n                    if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 ||\n                        (series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2])) {\n                        series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n                        if (series.type === 'Waterfall') {\n                            var rectElements = seriesElement.childNodes;\n                            for (var i = 0; i < rectElements.length; i++) {\n                                if (rectElements[i].id.indexOf('Connector') !== -1) {\n                                    rectElements[i].style.visibility = 'visible';\n                                    rectElements[i].setAttribute('transform', 'translate(0,0)');\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * To get rounded rect path direction\n     */\n    ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight) {\n        return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) +\n            ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' +\n            rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y +\n            ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' +\n            (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' +\n            (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight)\n            + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' +\n            (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' +\n            (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' +\n            (topLeft + rect.y) + ' ' + 'Z';\n    };\n    return ColumnBase;\n}());\nexport { ColumnBase };\n"]},"metadata":{},"sourceType":"module"}