{"ast":null,"code":"/**\n * Defines the common functionalities of accumulation series\n */\nimport { isNullOrUndefined, Animation, createElement } from '@syncfusion/ej2-base';\nimport { degreeToLocation, getElement, indexFinder, linear } from '../../common/utils/helper';\nimport { pointByIndex } from '../model/acc-base';\n/**\n * Accumulation Base used to do some base calculation for accumulation chart.\n */\n\nvar AccumulationBase =\n/** @class */\nfunction () {\n  /** @private */\n  function AccumulationBase(accumulation) {\n    this.accumulation = accumulation;\n  }\n\n  Object.defineProperty(AccumulationBase.prototype, \"center\", {\n    /**\n     * Gets the center of the pie\n     * @private\n     */\n    get: function () {\n      return this.pieCenter || (this.accumulation.visibleSeries[0].type === 'Pie' ? this.accumulation.pieSeriesModule.center : null);\n    },\n\n    /**\n     * Sets the center of the pie\n     * @private\n     */\n    set: function (value) {\n      this.pieCenter = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AccumulationBase.prototype, \"radius\", {\n    /**\n     * Gets the radius of the pie\n     * @private\n     */\n    get: function () {\n      return this.pieRadius !== undefined ? this.pieRadius : this.accumulation.pieSeriesModule.radius;\n    },\n\n    /**\n     * Sets the radius of the pie\n     * @private\n     */\n    set: function (value) {\n      this.pieRadius = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AccumulationBase.prototype, \"labelRadius\", {\n    /**\n     * Gets the label radius of the pie\n     * @private\n     */\n    get: function () {\n      return this.pieLabelRadius !== undefined ? this.pieLabelRadius : this.accumulation.pieSeriesModule.labelRadius;\n    },\n\n    /**\n     * Sets the label radius of the pie\n     * @private\n     */\n    set: function (value) {\n      this.pieLabelRadius = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Checks whether the series is circular or not\n   * @private\n   */\n\n  AccumulationBase.prototype.isCircular = function () {\n    return this.accumulation.type === 'Pie';\n  };\n  /**\n   * To check various radius pie\n   * @private\n   */\n\n\n  AccumulationBase.prototype.isVariousRadius = function () {\n    return this.accumulation.pieSeriesModule.isRadiusMapped;\n  };\n  /**\n   * To process the explode on accumulation chart loading\n   * @private\n   */\n\n\n  AccumulationBase.prototype.processExplode = function (event) {\n    if (event.target.id.indexOf('_Series_') > -1 || event.target.id.indexOf('_datalabel_') > -1) {\n      var pointIndex = indexFinder(event.target.id).point;\n\n      if (isNaN(pointIndex) || event.target.id.indexOf('_datalabel_') > -1 && this.accumulation.visibleSeries[0].points[pointIndex].labelPosition === 'Outside') {\n        return null;\n      }\n\n      this.explodePoints(pointIndex, this.accumulation);\n      this.deExplodeAll(pointIndex, this.accumulation.enableAnimation ? 300 : 0);\n    }\n  };\n  /**\n   * To invoke the explode on accumulation chart loading\n   * @private\n   */\n\n\n  AccumulationBase.prototype.invokeExplode = function () {\n    var series = this.accumulation.visibleSeries[0];\n    var duration = this.accumulation.enableAnimation ? 300 : 0;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (point.isExplode) {\n        this.pointExplode(point.index, point, duration);\n      }\n    }\n\n    if (this.accumulation.accumulationSelectionModule && this.accumulation.selectionMode !== 'None' && this.accumulation.accumulationSelectionModule.selectedDataIndexes.length) {\n      for (var _b = 0, _c = this.accumulation.accumulationSelectionModule.selectedDataIndexes; _b < _c.length; _b++) {\n        var index = _c[_b];\n        this.explodePoints(index.point, this.accumulation, true);\n        this.deExplodeAll(index.point, duration);\n      }\n    }\n  };\n  /**\n   * To deExplode all points in the series\n   * @private\n   */\n\n\n  AccumulationBase.prototype.deExplodeAll = function (index, animationDuration) {\n    var pointId = this.accumulation.element.id + '_Series_0_Point_';\n    var points = this.accumulation.visibleSeries[0].points;\n\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var currentPoint = points_1[_i];\n\n      if (index !== currentPoint.index && !currentPoint.isSliced || currentPoint.isClubbed) {\n        currentPoint.isExplode = false;\n        this.deExplodeSlice(currentPoint.index, pointId, animationDuration);\n      }\n    }\n  };\n  /**\n   * To explode point by index\n   * @private\n   */\n\n\n  AccumulationBase.prototype.explodePoints = function (index, chart, explode) {\n    if (explode === void 0) {\n      explode = false;\n    }\n\n    var series = chart.visibleSeries[0];\n    var points = series.points;\n    var point = pointByIndex(index, points);\n    var explodePoints = true;\n    var duration = this.accumulation.enableAnimation ? 300 : 0;\n\n    if (isNullOrUndefined(point)) {\n      return null;\n    }\n\n    var clubPointsExploded = !explode && (point.isSliced || series.clubbedPoints.length && points[points.length - 1].index === series.clubbedPoints[series.clubbedPoints.length - 1].index);\n\n    if (series.type === 'Pie' && (clubPointsExploded || point.isClubbed)) {\n      explodePoints = this.clubPointExplode(index, point, series, points, chart, duration, explode, clubPointsExploded);\n    }\n\n    if (explodePoints) {\n      this.pointExplode(index, point, duration, explode);\n    }\n  };\n\n  AccumulationBase.prototype.getSum = function (points) {\n    var total = 0;\n    points.map(function (point) {\n      total += point.visible ? point.y : 0;\n    });\n    return total;\n  };\n\n  ;\n\n  AccumulationBase.prototype.clubPointExplode = function (index, point, series, points, chart, duration, explode, clubPointsExploded) {\n    if (explode === void 0) {\n      explode = false;\n    }\n\n    if (clubPointsExploded === void 0) {\n      clubPointsExploded = false;\n    }\n\n    if (point.isClubbed) {\n      chart.animateSeries = false;\n      points.splice(points.length - 1, 1);\n      series.clubbedPoints.map(function (point) {\n        point.visible = true;\n        point.isExplode = true;\n      });\n      chart.visibleSeries[0].points = points.concat(series.clubbedPoints);\n      this.deExplodeAll(index, duration);\n      series.sumOfPoints = this.getSum(chart.visibleSeries[0].points);\n      chart.refreshChart();\n      return false;\n    } else if (clubPointsExploded || point.isSliced) {\n      chart.animateSeries = false;\n      points.splice(points.length - series.clubbedPoints.length, series.clubbedPoints.length);\n      var clubPoint = series.generateClubPoint();\n      clubPoint.index = points.length;\n      clubPoint.color = series.clubbedPoints[0].color;\n      points.push(clubPoint);\n      series.sumOfPoints = this.getSum(points);\n      this.deExplodeAll(index, duration);\n      clubPoint.isExplode = false;\n      chart.visibleSeries[0].points = points;\n      chart.refreshChart();\n      this.pointExplode(clubPoint.index, points[clubPoint.index], 0, true);\n      clubPoint.isExplode = false;\n      this.deExplodeSlice(clubPoint.index, chart.element.id + '_Series_0_Point_', duration);\n\n      if (point.isSliced) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * To Explode points\n   * @param index\n   * @param point\n   * @param explode\n   */\n\n\n  AccumulationBase.prototype.pointExplode = function (index, point, duration, explode) {\n    var translate;\n    var pointId = this.accumulation.element.id + '_Series_0_Point_';\n    var chart = this.accumulation;\n\n    if (!this.isCircular()) {\n      translate = {\n        x: point.labelRegion && point.labelRegion.x < point.region.x ? -chart.explodeDistance : chart.explodeDistance,\n        y: 0\n      };\n    } else {\n      translate = degreeToLocation(point.midAngle, chart.explodeDistance, this.center);\n    }\n\n    if (this.isExplode(pointId + index) || explode) {\n      point.isExplode = true;\n      this.explodeSlice(index, translate, pointId, this.center || {\n        x: 0,\n        y: 0\n      }, duration);\n    } else {\n      point.isExplode = false;\n      this.deExplodeSlice(index, pointId, duration);\n    }\n  };\n  /**\n   * To check point is exploded by id\n   */\n\n\n  AccumulationBase.prototype.isExplode = function (id) {\n    var element = getElement(id);\n    var transform = element ? element.getAttribute('transform') : null;\n    return element && (transform === 'translate(0, 0)' || transform === null || transform === 'translate(0)');\n  };\n  /**\n   * To deExplode the point by index\n   */\n\n\n  AccumulationBase.prototype.deExplodeSlice = function (index, sliceId, animationDuration) {\n    var element = getElement(sliceId + index);\n\n    if (element) {\n      var borderElement = element.parentNode.lastChild.hasAttribute('transform');\n\n      if (borderElement) {\n        element.parentNode.lastChild.removeAttribute('transform');\n      }\n    }\n\n    var transform = element ? element.getAttribute('transform') : null;\n\n    if (this.accumulation.enableAnimation && element && transform && transform !== 'translate(0, 0)' && transform !== 'translate(0)') {\n      var result = /translate\\((-?\\d+\\.?\\d*),?\\s*(-?\\d+[.]?\\d*)?\\)/.exec(transform);\n      this.performAnimation(index, sliceId, 0, 0, +result[1], +result[2] || 0, animationDuration, true);\n    } else {\n      this.performAnimation(index, sliceId, 0, 0, 0, 0, animationDuration, true);\n    }\n  };\n  /**\n   * To translate the point elements by index and position\n   */\n\n\n  AccumulationBase.prototype.setTranslate = function (index, sliceId, position, transform) {\n    this.setElementTransform(sliceId + index, position);\n\n    if (this.accumulation.visibleSeries[0].dataLabel.visible) {\n      sliceId = this.accumulation.element.id + '_datalabel_Series_0_';\n      this.setElementTransform(sliceId + 'shape_' + index, position);\n      this.setElementTransform(sliceId + 'text_' + index, position + transform);\n      this.setElementTransform(sliceId + 'connector_' + index, position);\n    }\n  };\n  /**\n   * To translate the point element by id and position\n   */\n\n\n  AccumulationBase.prototype.setElementTransform = function (id, position) {\n    var element = getElement(id);\n\n    if (element) {\n      element.setAttribute('transform', position);\n    }\n  };\n  /**\n   * To translate the point elements by index position\n   */\n\n\n  AccumulationBase.prototype.explodeSlice = function (index, translate, sliceId, center, animationDuration) {\n    this.performAnimation(index, sliceId, 0, 0, translate.x - center.x, translate.y - center.y, animationDuration);\n  };\n  /**\n   * To Perform animation point explode\n   * @param index\n   * @param sliceId\n   * @param start\n   * @param endX\n   * @param endY\n   */\n\n\n  AccumulationBase.prototype.performAnimation = function (index, sliceId, startX, startY, endX, endY, duration, isReverse) {\n    var _this = this;\n\n    var chart = this.accumulation;\n    var seriesIndex;\n    var point;\n    var values = sliceId.split('_');\n    seriesIndex = parseInt(sliceId.split('_')[values.length - 3], 10);\n    point = chart.visibleSeries[seriesIndex].points[index];\n\n    if (duration <= 0) {\n      this.setTranslate(index, sliceId, 'translate(' + endX + ', ' + endY + ')', point.transform);\n      return null;\n    }\n\n    var xValue;\n    var yValue;\n    new Animation({}).animate(createElement('div'), {\n      duration: duration,\n      progress: function (args) {\n        xValue = linear(args.timeStamp, startX, endX, args.duration);\n        yValue = linear(args.timeStamp, startY, endY, args.duration);\n\n        _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? endX - xValue : xValue) + ', ' + (isReverse ? endY - yValue : yValue) + ')', point.transform);\n      },\n      end: function (model) {\n        _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? startX : endX) + ', ' + (isReverse ? startX : endY) + ')', point.transform);\n      }\n    });\n  };\n\n  return AccumulationBase;\n}();\n\nexport { AccumulationBase };","map":{"version":3,"sources":["C:/Users/Power GSM/Desktop/React-Fito-v1.0-9-April-2021V/React-Fito-v1.0-9-April-2021V/react-fito/node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/accumulation-base.js"],"names":["isNullOrUndefined","Animation","createElement","degreeToLocation","getElement","indexFinder","linear","pointByIndex","AccumulationBase","accumulation","Object","defineProperty","prototype","get","pieCenter","visibleSeries","type","pieSeriesModule","center","set","value","enumerable","configurable","pieRadius","undefined","radius","pieLabelRadius","labelRadius","isCircular","isVariousRadius","isRadiusMapped","processExplode","event","target","id","indexOf","pointIndex","point","isNaN","points","labelPosition","explodePoints","deExplodeAll","enableAnimation","invokeExplode","series","duration","_i","_a","length","isExplode","pointExplode","index","accumulationSelectionModule","selectionMode","selectedDataIndexes","_b","_c","animationDuration","pointId","element","points_1","currentPoint","isSliced","isClubbed","deExplodeSlice","chart","explode","clubPointsExploded","clubbedPoints","clubPointExplode","getSum","total","map","visible","y","animateSeries","splice","concat","sumOfPoints","refreshChart","clubPoint","generateClubPoint","color","push","translate","x","labelRegion","region","explodeDistance","midAngle","explodeSlice","transform","getAttribute","sliceId","borderElement","parentNode","lastChild","hasAttribute","removeAttribute","result","exec","performAnimation","setTranslate","position","setElementTransform","dataLabel","setAttribute","startX","startY","endX","endY","isReverse","_this","seriesIndex","values","split","parseInt","xValue","yValue","animate","progress","args","timeStamp","end","model"],"mappings":"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","sourcesContent":["/**\n * Defines the common functionalities of accumulation series\n */\nimport { isNullOrUndefined, Animation, createElement } from '@syncfusion/ej2-base';\nimport { degreeToLocation, getElement, indexFinder, linear } from '../../common/utils/helper';\nimport { pointByIndex } from '../model/acc-base';\n/**\n * Accumulation Base used to do some base calculation for accumulation chart.\n */\nvar AccumulationBase = /** @class */ (function () {\n    /** @private */\n    function AccumulationBase(accumulation) {\n        this.accumulation = accumulation;\n    }\n    Object.defineProperty(AccumulationBase.prototype, \"center\", {\n        /**\n         * Gets the center of the pie\n         * @private\n         */\n        get: function () {\n            return this.pieCenter || (this.accumulation.visibleSeries[0].type === 'Pie' ?\n                this.accumulation.pieSeriesModule.center : null);\n        },\n        /**\n         * Sets the center of the pie\n         * @private\n         */\n        set: function (value) {\n            this.pieCenter = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AccumulationBase.prototype, \"radius\", {\n        /**\n         * Gets the radius of the pie\n         * @private\n         */\n        get: function () {\n            return this.pieRadius !== undefined ? this.pieRadius :\n                this.accumulation.pieSeriesModule.radius;\n        },\n        /**\n         * Sets the radius of the pie\n         * @private\n         */\n        set: function (value) {\n            this.pieRadius = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AccumulationBase.prototype, \"labelRadius\", {\n        /**\n         * Gets the label radius of the pie\n         * @private\n         */\n        get: function () {\n            return this.pieLabelRadius !== undefined ? this.pieLabelRadius :\n                this.accumulation.pieSeriesModule.labelRadius;\n        },\n        /**\n         * Sets the label radius of the pie\n         * @private\n         */\n        set: function (value) {\n            this.pieLabelRadius = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Checks whether the series is circular or not\n     * @private\n     */\n    AccumulationBase.prototype.isCircular = function () {\n        return this.accumulation.type === 'Pie';\n    };\n    /**\n     * To check various radius pie\n     * @private\n     */\n    AccumulationBase.prototype.isVariousRadius = function () {\n        return this.accumulation.pieSeriesModule.isRadiusMapped;\n    };\n    /**\n     * To process the explode on accumulation chart loading\n     * @private\n     */\n    AccumulationBase.prototype.processExplode = function (event) {\n        if (event.target.id.indexOf('_Series_') > -1 || event.target.id.indexOf('_datalabel_') > -1) {\n            var pointIndex = indexFinder(event.target.id).point;\n            if (isNaN(pointIndex) || (event.target.id.indexOf('_datalabel_') > -1 &&\n                this.accumulation.visibleSeries[0].points[pointIndex].labelPosition === 'Outside')) {\n                return null;\n            }\n            this.explodePoints(pointIndex, this.accumulation);\n            this.deExplodeAll(pointIndex, this.accumulation.enableAnimation ? 300 : 0);\n        }\n    };\n    /**\n     * To invoke the explode on accumulation chart loading\n     * @private\n     */\n    AccumulationBase.prototype.invokeExplode = function () {\n        var series = this.accumulation.visibleSeries[0];\n        var duration = this.accumulation.enableAnimation ? 300 : 0;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            if (point.isExplode) {\n                this.pointExplode(point.index, point, duration);\n            }\n        }\n        if (this.accumulation.accumulationSelectionModule && this.accumulation.selectionMode !== 'None' &&\n            this.accumulation.accumulationSelectionModule.selectedDataIndexes.length) {\n            for (var _b = 0, _c = this.accumulation.accumulationSelectionModule.selectedDataIndexes; _b < _c.length; _b++) {\n                var index = _c[_b];\n                this.explodePoints(index.point, this.accumulation, true);\n                this.deExplodeAll(index.point, duration);\n            }\n        }\n    };\n    /**\n     * To deExplode all points in the series\n     * @private\n     */\n    AccumulationBase.prototype.deExplodeAll = function (index, animationDuration) {\n        var pointId = this.accumulation.element.id + '_Series_0_Point_';\n        var points = this.accumulation.visibleSeries[0].points;\n        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n            var currentPoint = points_1[_i];\n            if ((index !== currentPoint.index && !currentPoint.isSliced) || currentPoint.isClubbed) {\n                currentPoint.isExplode = false;\n                this.deExplodeSlice(currentPoint.index, pointId, animationDuration);\n            }\n        }\n    };\n    /**\n     * To explode point by index\n     * @private\n     */\n    AccumulationBase.prototype.explodePoints = function (index, chart, explode) {\n        if (explode === void 0) { explode = false; }\n        var series = chart.visibleSeries[0];\n        var points = series.points;\n        var point = pointByIndex(index, points);\n        var explodePoints = true;\n        var duration = this.accumulation.enableAnimation ? 300 : 0;\n        if (isNullOrUndefined(point)) {\n            return null;\n        }\n        var clubPointsExploded = !explode &&\n            (point.isSliced || (series.clubbedPoints.length &&\n                points[points.length - 1].index === series.clubbedPoints[series.clubbedPoints.length - 1].index));\n        if (series.type === 'Pie' && (clubPointsExploded || point.isClubbed)) {\n            explodePoints = this.clubPointExplode(index, point, series, points, chart, duration, explode, clubPointsExploded);\n        }\n        if (explodePoints) {\n            this.pointExplode(index, point, duration, explode);\n        }\n    };\n    AccumulationBase.prototype.getSum = function (points) {\n        var total = 0;\n        points.map(function (point) {\n            total += point.visible ? point.y : 0;\n        });\n        return total;\n    };\n    ;\n    AccumulationBase.prototype.clubPointExplode = function (index, point, series, points, chart, duration, explode, clubPointsExploded) {\n        if (explode === void 0) { explode = false; }\n        if (clubPointsExploded === void 0) { clubPointsExploded = false; }\n        if (point.isClubbed) {\n            chart.animateSeries = false;\n            points.splice(points.length - 1, 1);\n            series.clubbedPoints.map(function (point) {\n                point.visible = true;\n                point.isExplode = true;\n            });\n            chart.visibleSeries[0].points = points.concat(series.clubbedPoints);\n            this.deExplodeAll(index, duration);\n            series.sumOfPoints = this.getSum(chart.visibleSeries[0].points);\n            chart.refreshChart();\n            return false;\n        }\n        else if (clubPointsExploded || point.isSliced) {\n            chart.animateSeries = false;\n            points.splice(points.length - series.clubbedPoints.length, series.clubbedPoints.length);\n            var clubPoint = series.generateClubPoint();\n            clubPoint.index = points.length;\n            clubPoint.color = series.clubbedPoints[0].color;\n            points.push(clubPoint);\n            series.sumOfPoints = this.getSum(points);\n            this.deExplodeAll(index, duration);\n            clubPoint.isExplode = false;\n            chart.visibleSeries[0].points = points;\n            chart.refreshChart();\n            this.pointExplode(clubPoint.index, points[clubPoint.index], 0, true);\n            clubPoint.isExplode = false;\n            this.deExplodeSlice(clubPoint.index, chart.element.id + '_Series_0_Point_', duration);\n            if (point.isSliced) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * To Explode points\n     * @param index\n     * @param point\n     * @param explode\n     */\n    AccumulationBase.prototype.pointExplode = function (index, point, duration, explode) {\n        var translate;\n        var pointId = this.accumulation.element.id + '_Series_0_Point_';\n        var chart = this.accumulation;\n        if (!this.isCircular()) {\n            translate = {\n                x: ((point.labelRegion && point.labelRegion.x < point.region.x) ? -chart.explodeDistance :\n                    chart.explodeDistance), y: 0\n            };\n        }\n        else {\n            translate = degreeToLocation(point.midAngle, chart.explodeDistance, this.center);\n        }\n        if (this.isExplode(pointId + index) || explode) {\n            point.isExplode = true;\n            this.explodeSlice(index, translate, pointId, this.center || { x: 0, y: 0 }, duration);\n        }\n        else {\n            point.isExplode = false;\n            this.deExplodeSlice(index, pointId, duration);\n        }\n    };\n    /**\n     * To check point is exploded by id\n     */\n    AccumulationBase.prototype.isExplode = function (id) {\n        var element = getElement(id);\n        var transform = element ? element.getAttribute('transform') : null;\n        return (element && (transform === 'translate(0, 0)' || transform === null || transform === 'translate(0)'));\n    };\n    /**\n     * To deExplode the point by index\n     */\n    AccumulationBase.prototype.deExplodeSlice = function (index, sliceId, animationDuration) {\n        var element = getElement(sliceId + index);\n        if (element) {\n            var borderElement = element.parentNode.lastChild.hasAttribute('transform');\n            if (borderElement) {\n                element.parentNode.lastChild.removeAttribute('transform');\n            }\n        }\n        var transform = element ? element.getAttribute('transform') : null;\n        if (this.accumulation.enableAnimation && element && transform &&\n            transform !== 'translate(0, 0)' && transform !== 'translate(0)') {\n            var result = /translate\\((-?\\d+\\.?\\d*),?\\s*(-?\\d+[.]?\\d*)?\\)/.exec(transform);\n            this.performAnimation(index, sliceId, 0, 0, +result[1], +result[2] || 0, animationDuration, true);\n        }\n        else {\n            this.performAnimation(index, sliceId, 0, 0, 0, 0, animationDuration, true);\n        }\n    };\n    /**\n     * To translate the point elements by index and position\n     */\n    AccumulationBase.prototype.setTranslate = function (index, sliceId, position, transform) {\n        this.setElementTransform(sliceId + index, position);\n        if (this.accumulation.visibleSeries[0].dataLabel.visible) {\n            sliceId = this.accumulation.element.id + '_datalabel_Series_0_';\n            this.setElementTransform(sliceId + 'shape_' + index, position);\n            this.setElementTransform(sliceId + 'text_' + index, position + transform);\n            this.setElementTransform(sliceId + 'connector_' + index, position);\n        }\n    };\n    /**\n     * To translate the point element by id and position\n     */\n    AccumulationBase.prototype.setElementTransform = function (id, position) {\n        var element = getElement(id);\n        if (element) {\n            element.setAttribute('transform', position);\n        }\n    };\n    /**\n     * To translate the point elements by index position\n     */\n    AccumulationBase.prototype.explodeSlice = function (index, translate, sliceId, center, animationDuration) {\n        this.performAnimation(index, sliceId, 0, 0, translate.x - center.x, translate.y - center.y, animationDuration);\n    };\n    /**\n     * To Perform animation point explode\n     * @param index\n     * @param sliceId\n     * @param start\n     * @param endX\n     * @param endY\n     */\n    AccumulationBase.prototype.performAnimation = function (index, sliceId, startX, startY, endX, endY, duration, isReverse) {\n        var _this = this;\n        var chart = this.accumulation;\n        var seriesIndex;\n        var point;\n        var values = sliceId.split('_');\n        seriesIndex = parseInt(sliceId.split('_')[values.length - 3], 10);\n        point = chart.visibleSeries[seriesIndex].points[index];\n        if (duration <= 0) {\n            this.setTranslate(index, sliceId, 'translate(' + (endX) + ', ' + (endY) + ')', point.transform);\n            return null;\n        }\n        var xValue;\n        var yValue;\n        new Animation({}).animate(createElement('div'), {\n            duration: duration,\n            progress: function (args) {\n                xValue = linear(args.timeStamp, startX, endX, args.duration);\n                yValue = linear(args.timeStamp, startY, endY, args.duration);\n                _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? endX - xValue : xValue) + ', ' + (isReverse ? endY - yValue : yValue) + ')', point.transform);\n            },\n            end: function (model) {\n                _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? startX : endX) + ', ' + (isReverse ? startX : endY) + ')', point.transform);\n            }\n        });\n    };\n    return AccumulationBase;\n}());\nexport { AccumulationBase };\n"]},"metadata":{},"sourceType":"module"}