{"ast":null,"code":"import { Marker } from './marker';\nimport { TextOption, renderTextElement } from '../../smithchart/utils/helper';\nimport { SmithchartRect, LineSegment, PointRegion, DataLabelTextOptions } from '../../smithchart/utils/utils';\nimport { _getEpsilonValue, PathOption, RectOption, getAnimationFunction, templateAnimate } from '../../smithchart/utils/helper';\nimport { animationComplete } from '../../smithchart/model/constant';\nimport { DataLabel } from '../../smithchart/series/datalabel';\nimport { Animation } from '@syncfusion/ej2-base';\nimport { textRender, seriesRender } from '../model/constant';\n/* tslint:disable:no-string-literal */\n\nvar SeriesRender =\n/** @class */\nfunction () {\n  function SeriesRender() {\n    this.xValues = [];\n    this.yValues = [];\n    this.pointsRegion = [];\n    this.lineSegments = [];\n    this.location = [];\n    this.dataLabel = new DataLabel();\n  }\n\n  SeriesRender.prototype.processData = function (series) {\n    var dataArray = series.dataSource;\n    var resistance = series.resistance;\n    var reactance = series.reactance;\n    var tooltip = series.tooltipMappingName;\n    series.points = [];\n\n    for (var i = 0; i < dataArray.length; i++) {\n      series.points.push({\n        resistance: dataArray[i][resistance],\n        reactance: dataArray[i][reactance],\n        tooltip: dataArray[i][tooltip]\n      });\n    }\n  }; // tslint:disable:max-func-body-length\n\n\n  SeriesRender.prototype.draw = function (smithchart, axisRender, bounds) {\n    var groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_seriesCollections'\n    });\n    var resistantCx;\n    var reactanceCy;\n    var series = smithchart.series;\n    var seriesLength = series.length;\n    var chartAreaRadius = axisRender.areaRadius;\n    var interSectPoint;\n    var index;\n\n    for (var m = 0; m < seriesLength; m++) {\n      var seriesIndex = m;\n\n      if (series[m].dataSource && series[m].resistance && series[m].reactance) {\n        this.processData(series[m]);\n      }\n\n      this.pointsRegion[m] = [];\n      this.location[m] = [];\n\n      for (var j = 0; j < series[m].points.length; j++) {\n        this.xValues[j] = series[m].points[j]['resistance'];\n        this.yValues[j] = series[m].points[j]['reactance'];\n      }\n\n      var chartAreaCx = axisRender.circleCenterX;\n      var chartAreaCy = axisRender.circleCenterY;\n      var diameter = axisRender.areaRadius * 2;\n      var reactanceStartPoint = {\n        x: chartAreaCx + (smithchart.renderType === 'Impedance' ? chartAreaRadius : -chartAreaRadius),\n        y: chartAreaCy\n      };\n      var resistantCy = chartAreaCy;\n      var reactanceCx = reactanceStartPoint.x;\n\n      for (var k = 0; k < series[m].points.length; k++) {\n        var resistance = this.xValues[k];\n        var resistantR = diameter * (1 / (resistance + 1)) / 2;\n        var reactance = this.yValues[k];\n        var reactanceR = Math.abs(1 / reactance * diameter / 2);\n\n        if (smithchart.renderType === 'Impedance') {\n          reactanceCy = reactance > 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;\n          resistantCx = axisRender.circleLeftX + diameter - resistantR;\n        } else {\n          reactanceCy = reactance < 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;\n          resistantCx = axisRender.circleLeftX + resistantR;\n        }\n\n        interSectPoint = axisRender.intersectingCirclePoints(reactanceCx, reactanceCy, reactanceR, resistantCx, resistantCy, resistantR, smithchart.renderType);\n\n        var epsilon = _getEpsilonValue();\n\n        if (Math.abs(reactance) < epsilon) {\n          interSectPoint.x = smithchart.renderType === 'Impedance' ? resistantCx - resistantR : resistantCx + resistantR;\n          interSectPoint.y = chartAreaCy;\n        }\n\n        this.pointsRegion[m][k] = new PointRegion();\n        this.pointsRegion[m][k] = {\n          point: interSectPoint,\n          x: resistance,\n          y: reactance\n        };\n        this.location[m][k] = {\n          x: interSectPoint.x,\n          y: interSectPoint.y\n        };\n      }\n\n      for (var i = 0; i < series[m].points.length - 1; i++) {\n        index = i + 1;\n        this.lineSegments[i] = new LineSegment();\n        this.lineSegments[i] = {\n          x1: this.xValues[i],\n          y1: this.yValues[i],\n          x2: this.xValues[index],\n          y2: this.yValues[index]\n        };\n      }\n\n      smithchart.svgObject.appendChild(groupElement);\n      this.drawSeries(smithchart, seriesIndex, groupElement, bounds);\n    }\n\n    for (var j = 0; j < smithchart.series.length; j++) {\n      if (smithchart.series[j].enableSmartLabels && smithchart.series[j].marker.dataLabel.visible) {\n        var gdlcEle = smithchart.renderer.createGroup({\n          'id': smithchart.element.id + '_svg' + '_series' + j + '_Datalabel' + '_connectorLines'\n        });\n        var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);\n\n        if (element) {\n          element.appendChild(gdlcEle);\n        }\n\n        this.dataLabel.calculateSmartLabels(this.dataLabel.labelOptions[j], j);\n\n        for (var k = 0; k < smithchart.series[j].points.length; k++) {\n          var currentPoint = this.dataLabel.labelOptions[j]['textOptions'][k];\n\n          if (currentPoint.xPosition + currentPoint.width > smithchart.chartArea.x + smithchart.chartArea.width || currentPoint.xPosition < smithchart.chartArea.x || currentPoint.yPosition < smithchart.chartArea.y || currentPoint.yPosition + currentPoint.height > smithchart.chartArea.y + smithchart.chartArea.height) {\n            this.dataLabel.labelOptions[j].textOptions[k].connectorFlag = false;\n            this.dataLabel.labelOptions[j].textOptions[k].visible = false;\n          }\n\n          if (currentPoint['connectorFlag']) {\n            this.dataLabel.drawConnectorLines(smithchart, j, k, currentPoint, gdlcEle);\n          }\n        }\n      }\n    }\n\n    var _loop_1 = function (j) {\n      var dataLabel = smithchart.series[j].marker.dataLabel;\n\n      if (smithchart.series[j].marker.dataLabel.visible) {\n        var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);\n        var gdEle_1 = smithchart.renderer.createGroup({\n          'id': smithchart.element.id + '_svg' + '_series' + j + '_Datalabel'\n        });\n\n        if (element) {\n          element.appendChild(gdEle_1);\n        }\n\n        var _loop_2 = function (k) {\n          var currentPoint = this_1.dataLabel.labelOptions[j]['textOptions'][k];\n\n          if (!dataLabel.template && currentPoint.visible) {\n            var options_1 = new DataLabelTextOptions();\n            options_1 = this_1.dataLabel.labelOptions[j]['textOptions'][k];\n            var font_1 = dataLabel.textStyle;\n            var x = options_1['xPosition'];\n            var y = options_1['yPosition'];\n            var id = smithchart.element.id + '_Series' + j + '_Points' + k + '_dataLabel' + '_symbol' + k;\n            var fill = dataLabel['fill'] ? dataLabel['fill'] : smithchart.series[j].fill || smithchart.seriesColors[j % smithchart.seriesColors.length];\n            var border = smithchart.series[j].marker.dataLabel.border;\n            var rectOptions = new RectOption(id, fill, border, options_1['opacity'], new SmithchartRect(x, y, options_1['width'], options_1['height']));\n            var dataEle = smithchart.renderer.drawRectangle(rectOptions);\n            gdEle_1.appendChild(dataEle);\n            var textRenderEventArgs = {\n              text: options_1['text'],\n              x: options_1['x'],\n              y: options_1['y'],\n              seriesIndex: j,\n              pointIndex: k,\n              name: textRender,\n              cancel: false\n            };\n\n            var textRenderSuccess = function (args) {\n              if (!args.cancel) {\n                var textoptions = new TextOption(options_1['id'], args.x, args.y, 'start', args.text);\n                var color = font_1.color ? font_1.color : smithchart.themeStyle.dataLabel;\n                var element_1 = renderTextElement(textoptions, font_1, color, gdEle_1);\n                gdEle_1.appendChild(element_1);\n              }\n            };\n\n            textRenderSuccess.bind(this_1);\n            smithchart.trigger(textRender, textRenderEventArgs, textRenderSuccess);\n          } else if (dataLabel.template) {\n            var element_2 = document.getElementById(dataLabel.template + '_seriesIndex' + j + '_pointIndex' + k + smithchart.element.id);\n            element_2.style.left = this_1.dataLabel.labelOptions[j]['textOptions'][k].xPosition + 'px';\n            element_2.style.top = this_1.dataLabel.labelOptions[j]['textOptions'][k].yPosition + 'px';\n          }\n        };\n\n        for (var k = 0; k < smithchart.series[j].points.length; k++) {\n          _loop_2(k);\n        }\n      }\n    };\n\n    var this_1 = this;\n\n    for (var j = 0; j < smithchart.series.length; j++) {\n      _loop_1(j);\n    }\n\n    for (var i = 0; i < smithchart.series.length; i++) {\n      if (smithchart.series[i].enableAnimation && smithchart.animateSeries) {\n        if (smithchart.series[i].marker.dataLabel.template) {\n          this.animateDataLabelTemplate(i, smithchart);\n        }\n\n        var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + i);\n        this.performAnimation(smithchart, element, i);\n      }\n    }\n  };\n\n  SeriesRender.prototype.drawSeries = function (smithchart, seriesindex, groupElement, bounds) {\n    var _this = this;\n\n    var gsEle = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_seriesCollection' + seriesindex,\n      'clip-path': 'url(#' + smithchart.element.id + '_ChartSeriesClipRect_' + seriesindex + ')'\n    });\n    gsEle.setAttribute('visibility', smithchart.series[seriesindex].visibility);\n    groupElement.appendChild(gsEle);\n    var sb = '';\n    var path;\n    var marker = smithchart.series[seriesindex].marker;\n    var element;\n    var count = smithchart.series[seriesindex].points.length - 1;\n\n    for (var i = 0; i < count; i++) {\n      var point1 = this.pointsRegion[seriesindex][i]['point'];\n      var point2 = this.pointsRegion[seriesindex][i + 1]['point'];\n      sb = sb + ('M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'L' + ' ' + point2.x + ' ' + point2.y + ' ');\n    }\n\n    path = sb.toString();\n    var fill = smithchart.series[seriesindex].fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length];\n    var seriesEventArgs = {\n      text: smithchart.series[seriesindex].name,\n      fill: fill,\n      name: seriesRender,\n      cancel: false\n    };\n\n    var seriesRenderSuccess = function (args) {\n      if (!args.cancel) {\n        var options = new PathOption(smithchart.element.id + '_series' + seriesindex + '_points', 'none', smithchart.series[seriesindex].width, seriesEventArgs.fill, smithchart.series[seriesindex].opacity, 'none', path);\n        _this.clipRectElement = smithchart.renderer.drawClipPath(new RectOption(smithchart.element.id + '_ChartSeriesClipRect_' + seriesindex, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, {\n          x: bounds.x,\n          y: bounds.y,\n          width: smithchart.availableSize.width,\n          height: smithchart.availableSize.height\n        }));\n        gsEle.appendChild(_this.clipRectElement);\n        var gspEle = smithchart.renderer.createGroup({\n          'id': smithchart.element.id + '_svg' + seriesindex\n        });\n        element = smithchart.renderer.drawPath(options);\n        gspEle.appendChild(element);\n        gsEle.appendChild(gspEle);\n      }\n    };\n\n    seriesRenderSuccess.bind(this);\n    smithchart.trigger(seriesRender, seriesEventArgs, seriesRenderSuccess);\n    var markerrender = new Marker();\n    markerrender.drawMarker(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex]);\n    this.dataLabel.drawDataLabel(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex], bounds);\n  };\n\n  SeriesRender.prototype.animateDataLabelTemplate = function (seriesindex, smithchart) {\n    var length = smithchart.series[seriesindex].points.length;\n    var opacity = 0;\n    var delay = 0;\n    var duration = parseFloat(smithchart.series[seriesindex].animationDuration);\n\n    for (var i = 0; i < length; i++) {\n      var element = document.getElementById(smithchart.series[seriesindex].marker.dataLabel.template + '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id);\n      element.style.visibility = 'hidden';\n      templateAnimate(smithchart, element, delay, duration, 'FadeIn'); // this.fadein(element);\n    }\n  };\n  /*private fadein(element: HTMLElement): void {\n    let op: number = 0.1;\n    element.style.display = 'block';\n    let timer: number = setInterval( (): void => {\n          if (op >= 1) {\n              clearInterval(timer);\n          }\n          element.style.opacity = op.toString();\n          element.style.filter = 'alpha(opacity=' + op * 100 + ')';\n          op += op * 0.1;\n  }, 50);\n  \n  }*/\n\n\n  SeriesRender.prototype.performAnimation = function (smithchart, gsEle, seriesIndex) {\n    var animation = new Animation({});\n    var element = document.getElementById('container_svg_seriesCollections');\n    var clipRect = gsEle.childNodes[0].childNodes[0].childNodes[0];\n    var effect = getAnimationFunction('Linear');\n    var reveffect = getAnimationFunction('Reverse');\n    var width = +clipRect.getAttribute('width');\n    var x = +clipRect.getAttribute('x');\n    var value;\n    animation.animate(clipRect, {\n      duration: parseFloat(smithchart.series[seriesIndex].animationDuration),\n      progress: function (args) {\n        if (smithchart.renderType === 'Impedance') {\n          value = effect(args.timeStamp - args.delay, 0, width, args.duration);\n          clipRect.setAttribute('width', value.toString());\n        } else {\n          value = reveffect(args.timeStamp - args.delay, width, 0, args.duration);\n          clipRect.setAttribute('x', value.toString());\n        }\n      },\n      end: function (model) {\n        if (smithchart.renderType === 'Impedance') {\n          clipRect.setAttribute('width', width.toString());\n        } else {\n          clipRect.setAttribute('x', x.toString());\n        }\n\n        var event = {\n          cancel: false,\n          name: animationComplete,\n          smithchart: !smithchart.isBlazor ? smithchart : null\n        };\n        smithchart.trigger(animationComplete, event);\n      }\n    });\n  };\n\n  SeriesRender.prototype.getLocation = function (seriesindex, pointIndex) {\n    var x;\n    var y;\n    x = this.location[seriesindex][pointIndex].x;\n    y = this.location[seriesindex][pointIndex].y;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  return SeriesRender;\n}();\n\nexport { SeriesRender };","map":{"version":3,"sources":["C:/Users/Power GSM/Desktop/React-Fito-v1.0-9-April-2021V/React-Fito-v1.0-9-April-2021V/react-fito/node_modules/@syncfusion/ej2-charts/src/smithchart/series/seriesrender.js"],"names":["Marker","TextOption","renderTextElement","SmithchartRect","LineSegment","PointRegion","DataLabelTextOptions","_getEpsilonValue","PathOption","RectOption","getAnimationFunction","templateAnimate","animationComplete","DataLabel","Animation","textRender","seriesRender","SeriesRender","xValues","yValues","pointsRegion","lineSegments","location","dataLabel","prototype","processData","series","dataArray","dataSource","resistance","reactance","tooltip","tooltipMappingName","points","i","length","push","draw","smithchart","axisRender","bounds","groupElement","renderer","createGroup","element","id","resistantCx","reactanceCy","seriesLength","chartAreaRadius","areaRadius","interSectPoint","index","m","seriesIndex","j","chartAreaCx","circleCenterX","chartAreaCy","circleCenterY","diameter","reactanceStartPoint","x","renderType","y","resistantCy","reactanceCx","k","resistantR","reactanceR","Math","abs","circleLeftX","intersectingCirclePoints","epsilon","point","x1","y1","x2","y2","svgObject","appendChild","drawSeries","enableSmartLabels","marker","visible","gdlcEle","document","getElementById","calculateSmartLabels","labelOptions","currentPoint","xPosition","width","chartArea","yPosition","height","textOptions","connectorFlag","drawConnectorLines","_loop_1","gdEle_1","_loop_2","this_1","template","options_1","font_1","textStyle","fill","seriesColors","border","rectOptions","dataEle","drawRectangle","textRenderEventArgs","text","pointIndex","name","cancel","textRenderSuccess","args","textoptions","color","themeStyle","element_1","bind","trigger","element_2","style","left","top","enableAnimation","animateSeries","animateDataLabelTemplate","performAnimation","seriesindex","_this","gsEle","setAttribute","visibility","sb","path","count","point1","point2","toString","seriesEventArgs","seriesRenderSuccess","options","opacity","clipRectElement","drawClipPath","availableSize","gspEle","drawPath","markerrender","drawMarker","drawDataLabel","delay","duration","parseFloat","animationDuration","animation","clipRect","childNodes","effect","reveffect","getAttribute","value","animate","progress","timeStamp","end","model","event","isBlazor","getLocation"],"mappings":"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","sourcesContent":["import { Marker } from './marker';\nimport { TextOption, renderTextElement } from '../../smithchart/utils/helper';\nimport { SmithchartRect, LineSegment, PointRegion, DataLabelTextOptions } from '../../smithchart/utils/utils';\nimport { _getEpsilonValue, PathOption, RectOption, getAnimationFunction, templateAnimate } from '../../smithchart/utils/helper';\nimport { animationComplete } from '../../smithchart/model/constant';\nimport { DataLabel } from '../../smithchart/series/datalabel';\nimport { Animation } from '@syncfusion/ej2-base';\nimport { textRender, seriesRender } from '../model/constant';\n/* tslint:disable:no-string-literal */\nvar SeriesRender = /** @class */ (function () {\n    function SeriesRender() {\n        this.xValues = [];\n        this.yValues = [];\n        this.pointsRegion = [];\n        this.lineSegments = [];\n        this.location = [];\n        this.dataLabel = new DataLabel();\n    }\n    SeriesRender.prototype.processData = function (series) {\n        var dataArray = series.dataSource;\n        var resistance = series.resistance;\n        var reactance = series.reactance;\n        var tooltip = series.tooltipMappingName;\n        series.points = [];\n        for (var i = 0; i < dataArray.length; i++) {\n            series.points.push({\n                resistance: dataArray[i][resistance],\n                reactance: dataArray[i][reactance],\n                tooltip: dataArray[i][tooltip]\n            });\n        }\n    };\n    // tslint:disable:max-func-body-length\n    SeriesRender.prototype.draw = function (smithchart, axisRender, bounds) {\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_seriesCollections' });\n        var resistantCx;\n        var reactanceCy;\n        var series = smithchart.series;\n        var seriesLength = series.length;\n        var chartAreaRadius = axisRender.areaRadius;\n        var interSectPoint;\n        var index;\n        for (var m = 0; m < seriesLength; m++) {\n            var seriesIndex = m;\n            if (series[m].dataSource && series[m].resistance && series[m].reactance) {\n                this.processData(series[m]);\n            }\n            this.pointsRegion[m] = [];\n            this.location[m] = [];\n            for (var j = 0; j < series[m].points.length; j++) {\n                this.xValues[j] = series[m].points[j]['resistance'];\n                this.yValues[j] = series[m].points[j]['reactance'];\n            }\n            var chartAreaCx = axisRender.circleCenterX;\n            var chartAreaCy = axisRender.circleCenterY;\n            var diameter = axisRender.areaRadius * 2;\n            var reactanceStartPoint = {\n                x: chartAreaCx + ((smithchart.renderType === 'Impedance') ?\n                    chartAreaRadius : -chartAreaRadius), y: chartAreaCy\n            };\n            var resistantCy = chartAreaCy;\n            var reactanceCx = reactanceStartPoint.x;\n            for (var k = 0; k < series[m].points.length; k++) {\n                var resistance = this.xValues[k];\n                var resistantR = (diameter * (1 / (resistance + 1))) / 2;\n                var reactance = this.yValues[k];\n                var reactanceR = Math.abs(((1 / reactance) * diameter) / 2);\n                if (smithchart.renderType === 'Impedance') {\n                    reactanceCy = reactance > 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;\n                    resistantCx = (axisRender.circleLeftX + diameter - resistantR);\n                }\n                else {\n                    reactanceCy = reactance < 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;\n                    resistantCx = (axisRender.circleLeftX + resistantR);\n                }\n                interSectPoint = axisRender.intersectingCirclePoints(reactanceCx, reactanceCy, reactanceR, resistantCx, resistantCy, resistantR, smithchart.renderType);\n                var epsilon = _getEpsilonValue();\n                if (Math.abs(reactance) < epsilon) {\n                    interSectPoint.x = (smithchart.renderType === 'Impedance') ?\n                        resistantCx - resistantR : resistantCx + resistantR;\n                    interSectPoint.y = chartAreaCy;\n                }\n                this.pointsRegion[m][k] = new PointRegion();\n                this.pointsRegion[m][k] = { point: interSectPoint, x: resistance, y: reactance };\n                this.location[m][k] = { x: interSectPoint.x, y: interSectPoint.y };\n            }\n            for (var i = 0; i < series[m].points.length - 1; i++) {\n                index = i + 1;\n                this.lineSegments[i] = new LineSegment();\n                this.lineSegments[i] = { x1: this.xValues[i], y1: this.yValues[i], x2: this.xValues[index], y2: this.yValues[index] };\n            }\n            smithchart.svgObject.appendChild(groupElement);\n            this.drawSeries(smithchart, seriesIndex, groupElement, bounds);\n        }\n        for (var j = 0; j < smithchart.series.length; j++) {\n            if (smithchart.series[j].enableSmartLabels && smithchart.series[j].marker.dataLabel.visible) {\n                var gdlcEle = smithchart.renderer.createGroup({\n                    'id': smithchart.element.id + '_svg'\n                        + '_series' + j + '_Datalabel' + '_connectorLines'\n                });\n                var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);\n                if (element) {\n                    element.appendChild(gdlcEle);\n                }\n                this.dataLabel.calculateSmartLabels(this.dataLabel.labelOptions[j], j);\n                for (var k = 0; k < smithchart.series[j].points.length; k++) {\n                    var currentPoint = this.dataLabel.labelOptions[j]['textOptions'][k];\n                    if ((currentPoint.xPosition + currentPoint.width) > (smithchart.chartArea.x + smithchart.chartArea.width)\n                        || currentPoint.xPosition < smithchart.chartArea.x || currentPoint.yPosition < smithchart.chartArea.y ||\n                        currentPoint.yPosition + currentPoint.height > smithchart.chartArea.y + smithchart.chartArea.height) {\n                        this.dataLabel.labelOptions[j].textOptions[k].connectorFlag = false;\n                        this.dataLabel.labelOptions[j].textOptions[k].visible = false;\n                    }\n                    if (currentPoint['connectorFlag']) {\n                        this.dataLabel.drawConnectorLines(smithchart, j, k, currentPoint, gdlcEle);\n                    }\n                }\n            }\n        }\n        var _loop_1 = function (j) {\n            var dataLabel = smithchart.series[j].marker.dataLabel;\n            if (smithchart.series[j].marker.dataLabel.visible) {\n                var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);\n                var gdEle_1 = smithchart.renderer.createGroup({\n                    'id': smithchart.element.id + '_svg'\n                        + '_series' + j + '_Datalabel'\n                });\n                if (element) {\n                    element.appendChild(gdEle_1);\n                }\n                var _loop_2 = function (k) {\n                    var currentPoint = this_1.dataLabel.labelOptions[j]['textOptions'][k];\n                    if (!dataLabel.template && currentPoint.visible) {\n                        var options_1 = new DataLabelTextOptions();\n                        options_1 = this_1.dataLabel.labelOptions[j]['textOptions'][k];\n                        var font_1 = dataLabel.textStyle;\n                        var x = options_1['xPosition'];\n                        var y = options_1['yPosition'];\n                        var id = smithchart.element.id + '_Series' + j + '_Points' + k + '_dataLabel' + '_symbol' + k;\n                        var fill = dataLabel['fill'] ? dataLabel['fill'] : (smithchart.series[j].fill ||\n                            smithchart.seriesColors[j % smithchart.seriesColors.length]);\n                        var border = smithchart.series[j].marker.dataLabel.border;\n                        var rectOptions = new RectOption(id, fill, border, options_1['opacity'], new SmithchartRect(x, y, options_1['width'], options_1['height']));\n                        var dataEle = smithchart.renderer.drawRectangle(rectOptions);\n                        gdEle_1.appendChild(dataEle);\n                        var textRenderEventArgs = {\n                            text: options_1['text'],\n                            x: options_1['x'],\n                            y: options_1['y'],\n                            seriesIndex: j,\n                            pointIndex: k,\n                            name: textRender,\n                            cancel: false\n                        };\n                        var textRenderSuccess = function (args) {\n                            if (!args.cancel) {\n                                var textoptions = new TextOption(options_1['id'], args.x, args.y, 'start', args.text);\n                                var color = font_1.color ? font_1.color : smithchart.themeStyle.dataLabel;\n                                var element_1 = renderTextElement(textoptions, font_1, color, gdEle_1);\n                                gdEle_1.appendChild(element_1);\n                            }\n                        };\n                        textRenderSuccess.bind(this_1);\n                        smithchart.trigger(textRender, textRenderEventArgs, textRenderSuccess);\n                    }\n                    else if (dataLabel.template) {\n                        var element_2 = document.getElementById(dataLabel.template + '_seriesIndex' + j + '_pointIndex' +\n                            k + smithchart.element.id);\n                        element_2.style.left = this_1.dataLabel.labelOptions[j]['textOptions'][k].xPosition + 'px';\n                        element_2.style.top = this_1.dataLabel.labelOptions[j]['textOptions'][k].yPosition + 'px';\n                    }\n                };\n                for (var k = 0; k < smithchart.series[j].points.length; k++) {\n                    _loop_2(k);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var j = 0; j < smithchart.series.length; j++) {\n            _loop_1(j);\n        }\n        for (var i = 0; i < smithchart.series.length; i++) {\n            if (smithchart.series[i].enableAnimation && smithchart.animateSeries) {\n                if (smithchart.series[i].marker.dataLabel.template) {\n                    this.animateDataLabelTemplate(i, smithchart);\n                }\n                var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + i);\n                this.performAnimation(smithchart, element, i);\n            }\n        }\n    };\n    SeriesRender.prototype.drawSeries = function (smithchart, seriesindex, groupElement, bounds) {\n        var _this = this;\n        var gsEle = smithchart.renderer.createGroup({\n            'id': smithchart.element.id + '_svg' + '_seriesCollection' + seriesindex,\n            'clip-path': 'url(#' + smithchart.element.id + '_ChartSeriesClipRect_' +\n                seriesindex + ')'\n        });\n        gsEle.setAttribute('visibility', smithchart.series[seriesindex].visibility);\n        groupElement.appendChild(gsEle);\n        var sb = '';\n        var path;\n        var marker = smithchart.series[seriesindex].marker;\n        var element;\n        var count = smithchart.series[seriesindex].points.length - 1;\n        for (var i = 0; i < count; i++) {\n            var point1 = this.pointsRegion[seriesindex][i]['point'];\n            var point2 = this.pointsRegion[seriesindex][i + 1]['point'];\n            sb = sb + ('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ' + 'L' +\n                ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n        }\n        path = sb.toString();\n        var fill = smithchart.series[seriesindex].fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length];\n        var seriesEventArgs = {\n            text: smithchart.series[seriesindex].name,\n            fill: fill,\n            name: seriesRender,\n            cancel: false\n        };\n        var seriesRenderSuccess = function (args) {\n            if (!args.cancel) {\n                var options = new PathOption(smithchart.element.id + '_series' + seriesindex + '_points', 'none', smithchart.series[seriesindex].width, seriesEventArgs.fill, smithchart.series[seriesindex].opacity, 'none', path);\n                _this.clipRectElement = smithchart.renderer.drawClipPath(new RectOption(smithchart.element.id + '_ChartSeriesClipRect_' + seriesindex, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                    x: bounds.x, y: bounds.y,\n                    width: smithchart.availableSize.width,\n                    height: smithchart.availableSize.height\n                }));\n                gsEle.appendChild(_this.clipRectElement);\n                var gspEle = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + seriesindex });\n                element = smithchart.renderer.drawPath(options);\n                gspEle.appendChild(element);\n                gsEle.appendChild(gspEle);\n            }\n        };\n        seriesRenderSuccess.bind(this);\n        smithchart.trigger(seriesRender, seriesEventArgs, seriesRenderSuccess);\n        var markerrender = new Marker();\n        markerrender.drawMarker(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex]);\n        this.dataLabel.drawDataLabel(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex], bounds);\n    };\n    SeriesRender.prototype.animateDataLabelTemplate = function (seriesindex, smithchart) {\n        var length = smithchart.series[seriesindex].points.length;\n        var opacity = 0;\n        var delay = 0;\n        var duration = parseFloat(smithchart.series[seriesindex].animationDuration);\n        for (var i = 0; i < length; i++) {\n            var element = document.getElementById(smithchart.series[seriesindex].marker.dataLabel.template +\n                '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id);\n            element.style.visibility = 'hidden';\n            templateAnimate(smithchart, element, delay, duration, 'FadeIn');\n            // this.fadein(element);\n        }\n    };\n    /*private fadein(element: HTMLElement): void {\n      let op: number = 0.1;\n      element.style.display = 'block';\n      let timer: number = setInterval( (): void => {\n            if (op >= 1) {\n                clearInterval(timer);\n            }\n            element.style.opacity = op.toString();\n            element.style.filter = 'alpha(opacity=' + op * 100 + ')';\n            op += op * 0.1;\n    }, 50);\n    \n    }*/\n    SeriesRender.prototype.performAnimation = function (smithchart, gsEle, seriesIndex) {\n        var animation = new Animation({});\n        var element = document.getElementById('container_svg_seriesCollections');\n        var clipRect = gsEle.childNodes[0].childNodes[0].childNodes[0];\n        var effect = getAnimationFunction('Linear');\n        var reveffect = getAnimationFunction('Reverse');\n        var width = +clipRect.getAttribute('width');\n        var x = +clipRect.getAttribute('x');\n        var value;\n        animation.animate(clipRect, {\n            duration: parseFloat(smithchart.series[seriesIndex].animationDuration),\n            progress: function (args) {\n                if (smithchart.renderType === 'Impedance') {\n                    value = effect(args.timeStamp - args.delay, 0, width, args.duration);\n                    clipRect.setAttribute('width', value.toString());\n                }\n                else {\n                    value = reveffect(args.timeStamp - args.delay, width, 0, args.duration);\n                    clipRect.setAttribute('x', value.toString());\n                }\n            },\n            end: function (model) {\n                if (smithchart.renderType === 'Impedance') {\n                    clipRect.setAttribute('width', width.toString());\n                }\n                else {\n                    clipRect.setAttribute('x', x.toString());\n                }\n                var event = {\n                    cancel: false,\n                    name: animationComplete,\n                    smithchart: !smithchart.isBlazor ? smithchart : null\n                };\n                smithchart.trigger(animationComplete, event);\n            }\n        });\n    };\n    SeriesRender.prototype.getLocation = function (seriesindex, pointIndex) {\n        var x;\n        var y;\n        x = this.location[seriesindex][pointIndex].x;\n        y = this.location[seriesindex][pointIndex].y;\n        return { x: x, y: y };\n    };\n    return SeriesRender;\n}());\nexport { SeriesRender };\n"]},"metadata":{},"sourceType":"module"}