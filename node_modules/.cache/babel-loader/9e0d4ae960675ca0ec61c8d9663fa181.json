{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getPoint, withInRange, ChartLocation } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { MultiColoredSeries } from './multi-colored-base';\n/**\n * `MultiColoredAreaSeries` module used to render the area series with multi color.\n */\n\nvar MultiColoredAreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(MultiColoredAreaSeries, _super);\n\n  function MultiColoredAreaSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render Area series.\n   * @return {void}\n   * @private\n   */\n\n\n  MultiColoredAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var _this = this;\n\n    var firstPoint;\n    var startPoint = null;\n    var direction = '';\n    var origin = Math.max(series.yAxis.visibleRange.min, 0);\n    var options = [];\n    var startRegion;\n    var previous;\n    var rendered;\n    var segments = this.sortSegments(series, series.segments);\n    series.visiblePoints.map(function (point, i, seriesPoints) {\n      point.symbolLocations = [];\n      point.regions = [];\n      rendered = false;\n\n      if (point.visible && withInRange(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {\n        direction += _this.getAreaPathDirection(point.xValue, origin, series, isInverted, getPoint, startPoint, 'M');\n        startPoint = startPoint || new ChartLocation(point.xValue, origin);\n        firstPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);\n\n        if (previous && _this.setPointColor(point, previous, series, series.segmentAxis === 'X', segments)) {\n          rendered = true;\n          startRegion = getPoint(startPoint.x, origin, xAxis, yAxis, isInverted, series);\n          direction += 'L' + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n          direction += 'L' + ' ' + firstPoint.x + ' ' + startRegion.y + ' ';\n\n          _this.generatePathOption(options, series, previous, direction, '_Point_' + previous.index);\n\n          direction = 'M' + ' ' + firstPoint.x + ' ' + startRegion.y + ' ' + 'L' + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n        } else {\n          direction += 'L' + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n\n          _this.setPointColor(point, null, series, series.segmentAxis === 'X', segments);\n        }\n\n        if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {\n          direction += _this.getAreaEmptyDirection({\n            'x': point.xValue,\n            'y': origin\n          }, startPoint, series, isInverted, getPoint);\n          startPoint = null;\n        }\n\n        previous = point;\n\n        _this.storePointLocation(point, series, isInverted, getPoint);\n      }\n    });\n\n    if (!isNullOrUndefined(rendered) && !rendered) {\n      direction = series.points.length > 1 ? direction + this.getAreaPathDirection(previous.xValue, origin, series, isInverted, getPoint, null, 'L') : '';\n      this.generatePathOption(options, series, previous, direction, '');\n    }\n\n    this.applySegmentAxis(series, options, segments);\n    this.renderMarker(series);\n  };\n  /**\n   * To Store the path directions of the area\n   */\n\n\n  MultiColoredAreaSeries.prototype.generatePathOption = function (options, series, point, direction, id) {\n    options.push(new PathOption(series.chart.element.id + '_Series_' + series.index + id, series.setPointColor(point, series.interior), series.border.width, series.border.color, series.opacity, series.dashArray, direction));\n  };\n  /**\n   * To destroy the area series.\n   * @return {void}\n   * @private\n   */\n\n\n  MultiColoredAreaSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n  /**\n   * Get module name\n   */\n\n\n  MultiColoredAreaSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'MultiColoredAreaSeries';\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  MultiColoredAreaSeries.prototype.doAnimation = function (series) {\n    this.doLinearAnimation(series, series.animation);\n  };\n\n  return MultiColoredAreaSeries;\n}(MultiColoredSeries);\n\nexport { MultiColoredAreaSeries };","map":{"version":3,"sources":["C:/Users/Power GSM/Desktop/React-Fito-v1.0-9-April-2021V/React-Fito-v1.0-9-April-2021V/react-fito/node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-area-series.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","getPoint","withInRange","ChartLocation","PathOption","isNullOrUndefined","MultiColoredSeries","MultiColoredAreaSeries","_super","apply","arguments","render","series","xAxis","yAxis","isInverted","_this","firstPoint","startPoint","direction","origin","Math","max","visibleRange","min","options","startRegion","previous","rendered","segments","sortSegments","visiblePoints","map","point","i","seriesPoints","symbolLocations","regions","visible","getAreaPathDirection","xValue","yValue","setPointColor","segmentAxis","x","y","generatePathOption","index","emptyPointSettings","mode","getAreaEmptyDirection","storePointLocation","points","length","applySegmentAxis","renderMarker","id","push","chart","element","interior","border","width","color","opacity","dashArray","destroy","getModuleName","doAnimation","doLinearAnimation","animation"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getPoint, withInRange, ChartLocation } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { MultiColoredSeries } from './multi-colored-base';\n/**\n * `MultiColoredAreaSeries` module used to render the area series with multi color.\n */\nvar MultiColoredAreaSeries = /** @class */ (function (_super) {\n    __extends(MultiColoredAreaSeries, _super);\n    function MultiColoredAreaSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render Area series.\n     * @return {void}\n     * @private\n     */\n    MultiColoredAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n        var _this = this;\n        var firstPoint;\n        var startPoint = null;\n        var direction = '';\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var options = [];\n        var startRegion;\n        var previous;\n        var rendered;\n        var segments = this.sortSegments(series, series.segments);\n        series.visiblePoints.map(function (point, i, seriesPoints) {\n            point.symbolLocations = [];\n            point.regions = [];\n            rendered = false;\n            if (point.visible && withInRange(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {\n                direction += _this.getAreaPathDirection(point.xValue, origin, series, isInverted, getPoint, startPoint, 'M');\n                startPoint = startPoint || new ChartLocation(point.xValue, origin);\n                firstPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);\n                if (previous && _this.setPointColor(point, previous, series, series.segmentAxis === 'X', segments)) {\n                    rendered = true;\n                    startRegion = getPoint(startPoint.x, origin, xAxis, yAxis, isInverted, series);\n                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (startRegion.y) + ' ');\n                    _this.generatePathOption(options, series, previous, direction, '_Point_' + previous.index);\n                    direction = 'M' + ' ' + (firstPoint.x) + ' ' + (startRegion.y) + ' ' + 'L' + ' ' +\n                        (firstPoint.x) + ' ' + (firstPoint.y) + ' ';\n                }\n                else {\n                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n                    _this.setPointColor(point, null, series, series.segmentAxis === 'X', segments);\n                }\n                if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {\n                    direction += _this.getAreaEmptyDirection({ 'x': point.xValue, 'y': origin }, startPoint, series, isInverted, getPoint);\n                    startPoint = null;\n                }\n                previous = point;\n                _this.storePointLocation(point, series, isInverted, getPoint);\n            }\n        });\n        if (!isNullOrUndefined(rendered) && !rendered) {\n            direction = series.points.length > 1 ?\n                (direction + this.getAreaPathDirection(previous.xValue, origin, series, isInverted, getPoint, null, 'L')) : '';\n            this.generatePathOption(options, series, previous, direction, '');\n        }\n        this.applySegmentAxis(series, options, segments);\n        this.renderMarker(series);\n    };\n    /**\n     * To Store the path directions of the area\n     */\n    MultiColoredAreaSeries.prototype.generatePathOption = function (options, series, point, direction, id) {\n        options.push(new PathOption(series.chart.element.id + '_Series_' + series.index + id, series.setPointColor(point, series.interior), series.border.width, series.border.color, series.opacity, series.dashArray, direction));\n    };\n    /**\n     * To destroy the area series.\n     * @return {void}\n     * @private\n     */\n    MultiColoredAreaSeries.prototype.destroy = function (chart) {\n        /**\n         * Destroy method calling here\n         */\n    };\n    /**\n     * Get module name\n     */\n    MultiColoredAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series\n         */\n        return 'MultiColoredAreaSeries';\n    };\n    /**\n     * Animates the series.\n     * @param  {Series} series - Defines the series to animate.\n     * @return {void}\n     */\n    MultiColoredAreaSeries.prototype.doAnimation = function (series) {\n        this.doLinearAnimation(series, series.animation);\n    };\n    return MultiColoredAreaSeries;\n}(MultiColoredSeries));\nexport { MultiColoredAreaSeries };\n"]},"metadata":{},"sourceType":"module"}